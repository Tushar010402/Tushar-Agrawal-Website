/**
 * QuantumShield TypeScript Wrapper
 *
 * This module provides TypeScript types and a convenient wrapper
 * around the QuantumShield WASM bindings.
 *
 * @example
 * ```typescript
 * import init, { QShieldKEM, QuantumShield } from 'quantum-shield';
 *
 * await init();
 *
 * const { publicKey, secretKey } = QShieldKEM.generateKeypair();
 * const { ciphertext, sharedSecret } = QShieldKEM.encapsulate(publicKey);
 *
 * const cipher = new QuantumShield(sharedSecret);
 * const encrypted = cipher.encrypt(new TextEncoder().encode('Hello!'));
 * const decrypted = cipher.decrypt(encrypted);
 * ```
 */

// Type definitions for the WASM module
// These will be generated by wasm-bindgen when the module is built

export interface QShieldKEMPublicKey {
  serialize(): Uint8Array;
}

export interface QShieldKEMSecretKey {
  // Secret key - no serialize method exposed for safety
}

export interface QShieldKEMCiphertext {
  serialize(): Uint8Array;
}

export interface QShieldSharedSecret {
  asBytes(): Uint8Array;
}

export interface QShieldKEMKeyPair {
  publicKey: QShieldKEMPublicKey;
  secretKey: QShieldKEMSecretKey;
}

export interface QShieldKEMEncapsulation {
  ciphertext: QShieldKEMCiphertext;
  sharedSecret: QShieldSharedSecret;
}

export interface QShieldSignPublicKey {
  serialize(): Uint8Array;
  fingerprint(): Uint8Array;
}

export interface QShieldSignSecretKey {
  // Secret key - no serialize method exposed for safety
}

export interface QShieldSignature {
  serialize(): Uint8Array;
  readonly timestamp?: bigint;
}

export interface QShieldSignKeyPair {
  publicKey: QShieldSignPublicKey;
  secretKey: QShieldSignSecretKey;
}

/**
 * Hybrid Key Encapsulation Mechanism
 *
 * Combines X25519 (classical) with ML-KEM-768 (post-quantum)
 * for defense-in-depth key exchange.
 */
export interface QShieldKEMStatic {
  /**
   * Generate a new hybrid key pair
   */
  generateKeypair(): QShieldKEMKeyPair;

  /**
   * Encapsulate a shared secret to a public key
   */
  encapsulate(publicKey: QShieldKEMPublicKey): QShieldKEMEncapsulation;

  /**
   * Decapsulate a shared secret from a ciphertext
   */
  decapsulate(
    secretKey: QShieldKEMSecretKey,
    ciphertext: QShieldKEMCiphertext
  ): QShieldSharedSecret;

  /**
   * Deserialize a public key
   */
  publicKeyFromBytes(bytes: Uint8Array): QShieldKEMPublicKey;

  /**
   * Deserialize a ciphertext
   */
  ciphertextFromBytes(bytes: Uint8Array): QShieldKEMCiphertext;
}

/**
 * Dual Digital Signature Scheme
 *
 * Combines ML-DSA-65 (lattice-based) with SLH-DSA (hash-based)
 * for quantum-resistant signatures.
 */
export interface QShieldSignStatic {
  /**
   * Generate a new dual signing key pair
   */
  generateKeypair(): QShieldSignKeyPair;

  /**
   * Sign a message with both algorithms
   */
  sign(secretKey: QShieldSignSecretKey, message: Uint8Array): QShieldSignature;

  /**
   * Sign a message with timestamp
   */
  signWithTimestamp(
    secretKey: QShieldSignSecretKey,
    message: Uint8Array,
    timestamp: bigint
  ): QShieldSignature;

  /**
   * Verify a dual signature
   */
  verify(
    publicKey: QShieldSignPublicKey,
    message: Uint8Array,
    signature: QShieldSignature
  ): boolean;

  /**
   * Deserialize a public key
   */
  publicKeyFromBytes(bytes: Uint8Array): QShieldSignPublicKey;

  /**
   * Deserialize a signature
   */
  signatureFromBytes(bytes: Uint8Array): QShieldSignature;
}

/**
 * Cascading Symmetric Encryption
 *
 * Encrypts data through AES-256-GCM then ChaCha20-Poly1305
 * for defense-in-depth symmetric encryption.
 */
export interface QuantumShieldCipher {
  /**
   * Encrypt data
   */
  encrypt(plaintext: Uint8Array): Uint8Array;

  /**
   * Encrypt data with additional authenticated data
   */
  encryptWithAad(plaintext: Uint8Array, aad: Uint8Array): Uint8Array;

  /**
   * Decrypt data
   */
  decrypt(ciphertext: Uint8Array): Uint8Array;

  /**
   * Decrypt data with additional authenticated data
   */
  decryptWithAad(ciphertext: Uint8Array, aad: Uint8Array): Uint8Array;

  /**
   * Rotate to new keys (provides forward secrecy)
   */
  rotateKeys(): void;

  /**
   * Get encryption overhead in bytes
   */
  overhead(): number;
}

export interface QuantumShieldStatic {
  new (sharedSecret: Uint8Array): QuantumShieldCipher;
}

/**
 * Key Derivation Functions
 */
export interface QShieldKDFInstance {
  /**
   * Derive a key using HKDF-SHA3-512
   */
  derive(
    ikm: Uint8Array,
    salt: Uint8Array | null,
    info: Uint8Array,
    length: number
  ): Uint8Array;

  /**
   * Derive a key from password using Argon2id
   */
  deriveFromPassword(
    password: Uint8Array,
    salt: Uint8Array,
    length: number
  ): Uint8Array;

  /**
   * Generate a quantum-resistant salt
   */
  generateSalt(length: number): Uint8Array;
}

export interface QShieldKDFStatic {
  new (): QShieldKDFInstance;
  withConfig(config: KdfConfig): QShieldKDFInstance;
}

export interface KdfConfig {
  memoryCost: number;
  timeCost: number;
  parallelism: number;
}

// Placeholder exports - these will be replaced by actual WASM bindings
export const QShieldKEM: QShieldKEMStatic = {} as QShieldKEMStatic;
export const QShieldSign: QShieldSignStatic = {} as QShieldSignStatic;
export const QuantumShield: QuantumShieldStatic = {} as QuantumShieldStatic;
export const QShieldKDF: QShieldKDFStatic = {} as QShieldKDFStatic;

/**
 * Initialize the WASM module
 *
 * Must be called before using any other functions.
 *
 * @example
 * ```typescript
 * import init from 'quantum-shield';
 * await init();
 * ```
 */
export default async function init(): Promise<void> {
  // This will be replaced by wasm-bindgen generated code
  console.log('QuantumShield WASM module loaded');
}
